lecture8.mp3
00:23 --> 13:13
Speaker 1:
DAVID MALAN: All right, this is CS50's introduction to programming with Python. My name is David Malan, and this is our week on object-oriented programming, or OOP. It turns out that in the world of programming, there's different paradigms of programming languages. There's different ways of solving problems with code. And it's a little hard to see this at first if you've only learned one language. But over time, if and when you learn other languages besides Python, you'll start to notice certain patterns and certain capabilities of some languages, but not another. building blocks in place. All right, but let me propose that we could be doing this a little bit differently. Get name get house is fine, but at the end of the day, I'm really trying to get a student from the user. I want their name and their house, not just one or the other. So maybe it would be a little cleaner still to define a function called get student and let get student do all of this work for us. Now theoretically get student could call get name and could call get house, house by also prompting them as before. And then now, hmm, I want to return the student, but I think I might have painted myself into a corner here, because I now have two variables, name and house. And yet, up until now, we've pretty much returned one or the other. We've returned one value. So any suggestions for how we can perhaps solve this problem that I just created for myself, whereby I want to return really a student, return a dictionary include the name and the house. Yeah, so we absolutely could return a dictionary, a dict object in Python, whereby maybe one key is name, one key is house, and the values thereof are exactly the values of these variables. So we could totally do that. I worry that that might be getting a little complicated. I wonder if there's a simpler way instead. Any other instincts, even if you're not sure it would work? Return both name and house. Return both name and house. I like the sound of that. It sounds simple. I don't have to figure out what a dictionary is going to look like. And in fact, this too would be a valid approach, even if you've not seen this before. It turns out in Python that you can kind of return multiple values, but that's a bit of a white lie. Or we could take Muhammad's approach of actually returning a dictionary and putting multiple keys therein. So here again, we have yet another example of how whereby you want to return multiple values would be to do something like this. I could go ahead and literally return not just name, but I could put a comma and also return house. This is not necessarily something you can do in other languages if you have programmed in other languages before. It depends on the language. But it looks like, thanks to this comma, maybe I can, in fact, return two values as actually proposed. Well, if I'm returning two values in this way on line 10, type in Gryffindor enter and we still have some working code. Let me pause here now and see if there are any questions. of returning a tuple and indexing into it in this way.
13:15 --> 13:17
Speaker 2:
like an actual use case where
13:17 --> 02:27:41
Speaker 1:
use a tuple versus a list or something else that's similar. It's a really good question. When would you use a tuple versus a list? When you want to program defensively or in general, when you know that the values in this variable shouldn't change. So why would you use a data type that allows them to be changed? It just invites mistakes, bugs down the line, either by you or colleagues who are interacting with your code. So tuple is just another way where you can increase the probability on of student.pi, let me go ahead and type in, for instance, how about Padma's name? And I'm going to go ahead and say that Padma's in Gryffindor, as in the movies. And we see Padma from Gryffindor. But technically, I went down this rabbit hole and looking at Harry Potter more closely. Technically, in the books, Padma, I believe, was from Ravenclaw. So this is actually a mistake or an inconsistency between the movies and the books. Let's see if we can't fix this inconsistency in our code. So how about we do this? working as intended. Let me clear my screen again, though, and run python of student.py on padma. And I'll put her to in Gryffindor as in the movies and hit enter. And now I just see a big mess of errors on the screen. Some kind of exception has been thrown and indeed a type error has happened. I'm using a data type wherein there's an error. And what is that error? Well, tuple object does not support item assignment. It's a little arcanely expressed. That is, that's not really very user friendly. So now we've corrected it to be Padma from Ravenclaw as in the books instead. couples versus lists, or this idea of immutability versus mutability. Uh, can we use a nested tuple in Python like a nest list? Absolutely. You can have not only nested lists in python where one of the elements in a list could be another list. So you have some square brackets out here. You might have some other square brackets inside. You can absolutely do the same with a tuple as well. There's no constraint on the types of values you can put in there. We've not had occasion to do that in In this case, I'm just returning a simple, a simple tuple with two elements. But yes, you could absolutely do that too. Other questions on tuples versus lists? Okay, for example, when I see the square bracket, is it mainly used for the list? Oh, a really good question. Sort of. So when you create a value like a list, you use square brackets and that would indeed be a visual indicator that this is definitely a list. If you instead see parentheses, that's a visual indicator when creating a value that it's definitely a tuple. However, somewhat confusingly, both lists and tuples use square brackets and 0 or location 1, you always use square brackets. So that's the distinction there. Good question. Allow me to propose now, if I may, that we solve this problem yet another way. And let's see if we're either making things better or for worse than us. Recall that dictionaries or dict objects also exist in Python. And a dictionary is this collection of keys and values. And the upside in particular of a dictionary is that they have better semantics. Right? You don't just have to assume that a name is always going to be at location 0, f string I the value of the name key, the value of the house key in this dictionary. But your audio is a little garbled for us, but I think I heard double quotes and single quotes. So I'm going to assume that indeed you've identified precisely the issue. I'm just going to confuse Python right now. Even though this is an f string inside of double quotes prefixed with an f, I can't actually use my double quotes inside my double quotes because that's going to confuse python indeed if I run this program now python of student.py and hit enter I get a syntax error. So the program didn't even run fully. It just couldn't be understood because it got confused by those double quotes. So the simplest fix here would indeed just be to use not double quotes but single quotes around the keys or conversely flip the double quotes on the outside to single quotes then use double quotes on the inside. You just want to be consistent. So a subtle detail. But again this is now specific to dictionary syntax. Gryffindor no syntax errors, no other errors. I think I'm back in business here. And what I do like to be clear about using a dictionary is that it's allowing me just better semantics. Again, I don't have to remember, memorize, document that zero is name. One is house. Instead, name is name and house is house. It's just a little clearer, a little more expressive. So that's generally a good thing, especially if we stored more data about students than just their name and their house. I might minimally then start moving my key value pairs to separate lines, but this would just be a slightly more compact way of doing this as well. But let me propose we do one more change. Let's go ahead and introduce that same special casing of Padma to fix her house, from Gryffindor, for instance, to Ravenclaw. How do we do this with dictionaries? Well, dictionaries like lists are mutable. You can change what is in them just like you can lists. How do you do that is just a little different syntactically. index into lists and tuples using numbers, but you index into dictionaries using strings as I've done here. All right, let me go ahead and run Python. I'm student.py. We'll again do Harry from Gryffindor. I think all is well. Let me run it one more time this time with Padma, who in the movies is from Gryffindor, but should really be from Ravenclaw. All right. Any questions then on this progression from tuples to lists to dictionaries? We haven't necessarily introduced anything new other than those tuples which have been available to us all this time. But the goal at the moment is just to demonstrate this distinction among these different data types and how they each work a little bit differently. A what if a combination of lists is there in a tuple. So is the list like we can change the list because tuple are immutable, but lists are mutable. DAVID MALAN: Correct. You can change the contents of lists and you can put most anything you want in them, other lists or strings as I've done, integers or anything else. Tuples, you can do the exact same thing, but you cannot change them once you've created them. A dictionary is more like a list in that it is mutable. You can change it. you index into a dictionary is by way of these keys, these strings, as we keep seeing, rather than by numbers, those numeric indices. All right, well, let me propose that there is yet another way of solving this problem. And indeed, I would argue that there's now an opportunity at hand. Even though this program isn't particularly complicated, all I'm doing is collecting a name from the user and a house from the user. You could imagine wanting longer term to collect even more information, then I'm going to go ahead and say student.house to give another attribute called house and give that the return value of input here, prompting the user for house. And then as before, I'm just going to return student. But now what's really powerful about class and object oriented programming more generally is that I've created this custom data type called literally student capital S. I've stored one such student in a variable like I can always do in a variable called student lowercase s. rerun python of student up by enter let's type in harry's name as before let's put him in gryffindor crossing our fingers as we often do and harry is indeed from gryffindor what though have i done let's introduce one other bit of terminology here it turns out that i can create a class using that class keyword but anytime you use a class you're creating what are data type and I don't have to kind of hack something together using a tuple or a list or even a dictionary. I now have a proper. data type called student that the authors of python didn't give me. I gave myself. Any questions now on classes, this new keyword class, or this idea of these objects or instances thereof? Is the class object mutable or immutable? DAVID MALAN: A good question. And we've clearly laid the stage for having that conversation about every data type. Now, we will see that they are mutable. but you can make them immutable. get the best of both worlds now by writing some actual code. And we'll write more code than the dot dot dot in just a bit. Other questions on classes or these objects thereof? Then what would be the properties of those classes? So at the moment, the properties of or the attributes of, as I've been calling them thus far, would just be name and house. It turns out that there may very well be other attributes built into classes that we may see before long. But for now, the only two attributes that I care about are the ones that I myself the name that I want to fill this this object with and the house that I want to put in that object as well. And now let me set the return value as before to be student equals like this. So what have I done that's different? Fundamentally, I'm still getting user input in the same way. I'm using input on line 11 and input on line 12. And I just so happen to be storing those return values in local variables. But now and now we're setting the stage for the more powerful features of classes and object oriented programming more generally. self dot house equals house. And this is like installing into the otherwise empty object, the value name and house and storing them in really identically named instance variables. It's in the object. And again, an object is just an instance of a class. Now, I know that was a lot of vocabulary. That's a lot of weird syntax. So any questions on this init method, whose purpose in life, again, is to initialize an otherwise empty object when you first create it? So what is the difference between the init method and the pod constructor? A good question. So in other languages, if you programmed before, for instance, Java, there are functions that are explicitly called constructors that indeed construct an object. They initialize it with values. of your class. that method initializes the contents of the object. So there's technically a distinction in constructing the object with new and initializing it within it. But in the world of python, you pretty much only worry about the init method. Python generally does the other part for you. A good question. Others. Uh, what about if you want to store more than one name or more than one house? A good question. If you want to store more than one name or more than one house, you can do this in different ways. You could create other attributes, technically called instance variables like self dot name one, implement a student singular so it doesn't makes sense to have multiple first names, maybe a nickname, maybe a last name. So we could add those two. But I don't think we need multiple names per se and in this case, multiple houses. But absolutely, you could do that using some of our familiar building blocks like lists. Other questions? How are classes or objects represented in memory? How are classes and objects represented in memory? So the class is technically just code. It is the code on the top of my file lines 1 through 4 that defines that blueprint, that template, if you will. are stored, but that's what python the program handles for you. Python the interpreter figures out where in the computer Sorry to put it, you and I, the programmers, get to think and solve problems at this level. Python, the interpreter, handles those lower level details for you. How about one final question on classes and objects? Now, my question is if we can do the same thing with the dictionary, so why to use classes? Good question. If you can do the same things as you can with dictionaries, why should you use classes? Because we are just scratching the surface now of what you can do with classes. Allow me to go back now to my keyboard and show you more of what improve or change the code, we're focusing really on just the minimal changes alone. So I've not fundamentally done anything different. I just got rid of the variable name and I'm just returning the return value of this student function that's constructing my new object for me. So I'm just tightening things up as we've done many times in the past. Well, what if something goes wrong when in creating this student? For instance, what if the user does not give us a name and they just hit Enter when prompted for name? list containing Gryffindor quote unquote Hufflepuff quote unquote. Uh, let's see Ravenclaw quote unquote or Slytherin quote unquote. Then with my colon, let's raise another type of value error. But rather than raise a generic value error, let's pass in an argument quote unquote invalid house. And so here we now see a capability that we can do with classes that we can't with dictionaries. or say, I raise this error. if I went in and wrote more code in my get student function, I could also catch this error with our usual try except send classes in our toolkit. even more powers when it comes to exceptions. not just catching them ourselves, but raising them ourselves too. Any questions now on this use of classes and in it and now this ability to raise exceptions when something goes wrong inside of the initialization. So what if the user has a middle name, name, middle name and last name? How would you fix that? A good question. If you wanted the user to if you wanted the student to have a first name, to take in more arguments if we want. We could even take a list if we wanted. But I think we'd probably want to have even more error checking then, not just for name, but for first and then maybe for middle and then maybe for last. So it just is more and more code. Though there would be ways to perhaps consolidate that too. Let me undo all of that and see if there are other questions now on classes. I assume this is classes or something I might do at the beginning of a project. Can I just put them in a different file and import them into my project or my main code as needed? Absolutely. A really good question. You could imagine wanting to use this student class not just in student.py, Next question on classes. Can you have optional variables So can you have your own error names like let's be egotistical and say I want to raise Eric error. Short answer. Yes. So you can these in it functions are just like python functions. More generally even though they're special and that they're going to get called automatically by python for you. But if you wanted to make house optional you could do something like this. You could give it a default value in the in it functions signature so to speak in that first line of code on line two. allow me to not have to pass in house in this case I'm going to continue to always pass in name and house but you could make things optional and yes to your second question if you wanted to have your own error message like an Eric error you could actually create your own Eric error exception and we'll see in a little bit that there's actually a whole suite of exceptions that exist and you too can invent those as well let me propose though that we now introduce one other aspect of this I just printed out a student, but now if I run Python of enter type in Harry type in Gryffindor. one more time hit enter Harry is again from Gryffindor but Yet again, let's for instance, do Draco is from Slytherin enter goes from Slytherin. Now it's customized to the specific object that we're trying to print. Questions on this function here, this dunder str method. Is there anything else that the _str method can do? The other question is, what's the difference between str and repr? DAVID MALAN: A good question. So there are many other methods that come with Python classes that start with _. function or method inside of this class. I want to give Harry and Hermione and all of the other students the ability to cast charms. So I'm going to define a function that I can completely on my own called charm. I could call this function anything I want. But because it's a method inside of a class, the convention is that it's always going to take at least one argument called self by convention so that you have access to the current object, even if you don't plan to use it per se. implement charm in such a way that the method returns an emoji that's appropriate for each student's patronus. All right, how to implement this? Well, inside of the charm method, let's go ahead and match on self.patronus, which is the instance variable containing a string that represents each student's And in the case that it matches a stag, for instance, for Harry, let's go ahead and return maybe the closest emoji, this horse here. How about in the case of an object? Well, in that case, let's go ahead and return, oh, maybe the closest match to the otter, which might be this emoji here. And let's see, in the case of a-- for Ron, rather than Hermione, a Jack Russell terrier, let's go ahead and return. How about-- don't have as many options here. Why don't we go ahead and return the cutest available dog in that case. I'm going to still get a student using the get student function. But rather than print student. So let's go ahead and declare expecto. patronum, printing out just that as pure text. And now let's go ahead and print out not the student, but rather the return value of their own charm method. All right, so let me go back down to my terminal window and run Python of student.py and Enter. Name, let's start with Harry. He lives in Gryffindor. Patronus is a stag. And let's see, expecto patronum. And of course, we see the stag emoji. which exists as before, and then I store the return value in a student variable, again on line 16. That will ensure that get student gets called, which calls input and input, and then it calls the student constructor, which invokes automatically this init method. So by way of how we've laid out my code, we're going to ensure that name is not blank, and house is definitely one of those four values. My error correction or error checking is in place. In order to access an attribute, you go through some function. And let's require that in order to set some attribute, you go through some function. And conventionally, those functions are called a getter function and a setter function. And why are we using functions, or in this case, methods inside of a class? Well, once you have functions, those are just actions or verbs that you and I can create ourselves. direction I want in these functions. this code that's going to get executed top to bottom. So how can I now prevent the user from setting the house to an invalid value? Let me borrow some logic from before rather than blindly set self dot house equal to the house value that's passed in. Let's add our error checking there. So if house is not in the following list of Gryffindor or Hufflepuff or Slytherin or Ravenclaw or Slytherin, just as before, let's go ahead and raise a value error just to signify that something has gone wrong. I'll be more explicit. directly, I'm going to use the setter instead. Why? Because the equal sign means I'm trying to set. I'm trying to assign a value from right to left into that attribute. So what Python's going to do automatically is call this function for me. And that's amazing because now I can execute code and algorithm to check, do I want to let the user? the programmer set that attribute to that value? If not, I'm going to raise a value error, and you're just not going to be able to do it. If so, fine. I'll go ahead and set it for you. But in order to do this, we need a little more syntax. And I'm going to get rid of my comments, and I'm going to use that decorator. I need to tell Python to treat this method as a getter. And then the syntax for the setter is a little different. You now say house.setter. I wish one was getter and the other was setter. you can now use a new decorator that's sort of automatically created for you called at house because I called it house. And then you literally say at house dot setter. And this whole line on line 17 is a clue to Python that here comes a function whose name is identical. But notice that it takes two arguments, both access to the contents of the object and house, which is just going to be a stir that comes from the programmer from like the human input return value so that you can set that value as well. But there's one fix I need to make now here. Everything else I think is still good. However, watch this. I no longer need this error check here. Why? Because if I scroll back down to my code here, also going to call my setter method, which is amazing because now I can keep all of my error checking in one place in the setter and it will now get called either when I create the object for the first time because of in it or even if the the programmer tries to circumvent that in it method and change the value of this attribute my setter will also get called my setter will get called anytime I access dot house but there's one fix I need to make unfortunately I have collided names right now if we go up here on line five this is an instance variable it's a string inside of myself inside of the current student object called name and this is value that's passed in in self dot house, but to use an almost identical name, but to use a little indicator that you means you know you're doing this correctly, you typically by convention put an underscore in front of the instance variables name. And when you return it up here, you similarly put an underscore. So now technically my instance variable is called underscore house, but my property, which is a fancier attribute, if you will, override it there. I think the only solution for me that line because it's just not going to work. Let me run python of student dot pi and again type in Harry. in Gryffindor enter and Harry's indeed from Gryffindor. If I something incorrect like Harry from number four privet drive enter. We're again going to see the value error because my code just doesn't let that value in via manual input now or via that adversarial change. All right. That was a lot. But any question on properties? While we are using getters and setters, it's just for the purpose so that we can find out to be able to go in there and just change them I want to have some control over that. so that you can just trust that it's to be correct as designed. So using a getter and center really just on to automatically detect when you're trying to manually set a value. The equal sign and the dot, as I've highlighted here, is enough of a clue to Python to realize, wait a minute, you're trying to set a value. Let me see if this class has a setter defined. And if so, I'm going to call that. And I'm not just going to blindly assign the value from right to left. So it's just giving me more control. Other questions on properties. When we use a getters, we just have just one argument. something else and the intuition for That is, if you're getting a value, you don't need to pass anything else in, because you already know the opposite. It's called student in this case. So you're just going to get the value of that property. But if you want to set the property to something else, you've got to pass in that argument. You've got to pass in the value to which you want to set it. So it's always 0 or 1. However, you see it as 1 or 2 because, again, any function inside of a class, a.k.a. a method, is going to be automatically passed self so that you have access to that current object in memory. How about one other question on properties? method, if I were to change this to do this, that would circumvent the setter. And now there's no error checking in it whatsoever. So it's such a fine line. The only thing standing between us and error checking or no error checking is the presence or absence of this underscore. But that's typically the convention. By not using the underscore there, make sure that even that assignment goes through the setter so that honestly, I don't have to copy paste the same error checking in two places. I can put it just in the setter. matching it, let me go back down to my terminal window and run Python of student.py enter. Let's type in Harry. Let's type in Gryffindor. And that seems to work. Let's try though again to run Python of student.py number four privet drive, this will not work. A value error with invalid house because that's not one of the four Hogwarts houses. And now for good measure, let's run it one more time and that's not even give it a name. Let's just hit enter when prompted. I can type anything for the house. I'll go ahead and still give it Gryffindor enter. Now we get another value error, but this one is for missing name. So we seem now to have all the more of a defense mechanism in place to ensure that name is as we expect. at the risk of bursting everyone's bubble and making you wonder, why did we just go through all of that? Unfortunately, Python really focuses on conventions, not hard constraints. And by that I mean this. If I go back into my main function after I've gotten a student on line 30 and I try to adversarially do something like this student dot house equals quote unquote number four privet drive. We know this won't work because my setter for house is going to catch this. Watch again, python of student dot pi. Let's type in Harry. Let's type in Gryffindor, which will at least pass our check that's induced by in it. And if some of you are already thinking a little adversarially, tragically, look what you can do. You can change dot house to be dot underscore house. Why? Well, the instance variable is now called underscore house. The property is called house, no underscore. But the underlying attribute implemented as an instance variable is still called underscore house. And tragically, Python of student dot pi, let's type in Harry. starts with an underscore, please don't touch it. Like, just don't. Like, that's on you if you touch that variable and break things. The underscore is meant to signify a convention that this is meant to be private, but it really just means please don't touch this. Sometimes if there's two underscores, which you can use too, that's an even greater effort by programmers to say really don't touch this. But technically speaking, there's nothing stopping you or me from circumventing all of these mechanisms, these properties, these getters and setters. change list to be not square brackets but curly braces. We've done this before. Anytime I've done two curly braces with nothing in between, this of course is an empty dictionary or a dict object in Python. Well, we can see that now. Let me clear my screen, run Python of type.py, enter. And there it is, class dict. It's been there this whole time. We just didn't call it a class until today. I can similarly do this one explicitly. Instead of two curly braces, let's write out dict with two parentheses. Now we have a lot of parentheses again, like with list. But this is just making even more clear that the type of a dict object is indeed the class dict itself. So this is to say that as new as a lot of today's idea and syntax might be, you've actually been using it, perhaps unbeknownst to you, for weeks now. We now just have terminology to describe what it is we've been doing all this time. what I want it to do yet. So I'm going to create this sort of placeholder dot dot dot. So I'll come back to that. Let's now try to use this class as though it existed. And from there, I perhaps can realize exactly what functionality that class needs to have to support my use case. Let me go ahead and create a variable called hat in all lowercase and instantiate a hat object. So no matter what the hat class ends up looking like, this is the common syntax for instantiating an object of a certain class. in this class. Well, let me go ahead and do this. If I don't care to parameterize hat, I just want to, for instance, sort values. and define this function sort first. So let's define sort as taking a first argument self, which is always going to be the case when defining an instance method as before. But the sort method clearly takes one argument from the programmer, me, namely the student's name. And again, we've seen this dichotomy before. Even though I'm trying to pass in one argument, when I define the method, it's got to take that many arguments plus one more, self, which is always going to be automatically passed in by Python first. All right, what do I want to do? Well, let's go ahead and do something like this. Print quote unquote or rather print this name. How about quote unquote is in quote unquote some house. I'm going to again use some placeholder code for myself because I'm not quite sure how to finish implementing this sorting hat. But I think that's enough to just test where my code is at now. Let me go ahead and run python of hat dot pi and hit enter. And it looks like indeed Harry is in some house. Harvard have constructed new houses over the years. So you might have to change the list of available houses. It didn't happen in seven books or eight films of Harry Potter, but you could imagine maybe Hogwarts initially has a fifth house. So there's generally some value in putting list of constants toward the top of your file, class so it's just obvious what the list of values is. You don't want to necessarily tuck it away in some function like Or, especially if you might want to use that function-- sorry, especially if you want to use that list in multiple functions, not just sort. But if I kept adding to this class, you might want to use that same list of houses in multiple functions. So let's keep it in the object itself by storing it in self.houses. All right. Well, we're about to change the course of history here, perhaps. Let me do Python of hat.py. And I think we're about to assign Harry to one of those four houses randomly. Huh. for a hat, but again, with classes come all this and even more functionality. But I honestly am not using classes in really the right way here. Why? Well, in the world of Harry Potter, there really is only, to my knowledge, one sorting hat. And yet here I have gone and implemented a class called hat. And again, a class is like a blueprint, a template, a mold that allows you to create one or more objects thereof. This is useful in some contexts, including this one. Why? Well, notice what I can now do. I can now change self to be just class. Why? Because houses now, not an instance variable accessible via self.houses. It is now a class variable accessible via class.houses, or technically cls.houses in this case. But now the final flourish is this. Now I don't have to instantiate any hat objects as I used to on here, type hat, I am just accessing a class method inside of the hat class that, you know what, is just going to work. work, you use the name of the class, capital letter and all, dot method name, passing in any arguments you want. Python is going to automatically pass in some variable via which you can refer to that class in that function that you've implemented inside of that class, so that I can do something like this. It's not that I want a variable. houses locally in this function, I want the variable called houses associated with this current class. So I can still access this same defined on line six. And now if I go back down here to my terminal and run Python of hat.py enter, Harry is still in Hufflepuff. Once more, Harry is still in Hufflepuff. in Gryffindor, at least randomly. Questions now on these class variables or these class methods, which are in contrast with instance variables and instance methods and the thing at least that's a little strange here is that even though there's a decorator called at class method, there is not one method, a method is just automatically a so-called instant method when you define it without any decorator. Can you have a class inside another class? You can. You can define one class inside of another. Generally speaking, this isn't done, but there are cases where it can be helpful, especially for larger, more sophisticated programs. So yes, it is possible. Good. Other questions. using the double. or init method to initialize the self.name and the self.house instance variables therein to those respective values. In this latest version of the sorting hat, I haven't bothered with self anywhere, only because conceptually, I don't need or want there to be multiple hats in the world. I'm just using the class as kind of a container to bundle up this list of houses, this sorting functionality. Maybe eventually I'll add more functionality to it, but that's it. And so sometimes you can use object-oriented programming in this somewhat different way when you want there to be functionality. code get more sophisticated, you're going to find that your code gets messy quickly. And you're going to find that you have a huge number of functions, for instance, in one file, and some of them are related to each other, but some of them are not. Well, at that point, wouldn't it be nice to just organize them a little differently? And in the world of Harry Potter, let's have a class for student. Let's have a class for professor. Let's have a class for the sorting hat. Let's have a class for something else. And so once your world gets much more complicated than some of the demonstrations we do here in on individual ideas, object-oriented programming is just a way of encapsulating related data, that is variables, related functionality, that is methods, inside of things that have names. These things are called classes. So it's just another way to solve problems. And when we focused on libraries a couple of weeks back, that too was another solution to the same problem. You could define your own modules or packages, put some of your data and/or functionality in there, and that's fine too. kind of randomly later in this file. So it's not wrong, but this is again evidence of much with this small program. But this is an example, again, of code smell. Like something smells a little off here. Like this is probably going to get us in trouble by separating related functionality. So again, it's a design principle, not a correctness concern. But class methods allow us to address this Let me go ahead and do this. I'm going to delete get student altogether, leaving only main as my other function here. And inside of my student class, I'm going to do this. I'm going to define a function even more simply called get and the nature of how class methods work, it's going to take in the name of the class itself or reference there too as an argument and I'm going to move the functionality me from get student into the student class. I'm going to do this. Name equals input quote unquote name. House equals input quote unquote house. And then what this function is going to do is return a new student object by calling class, which again is just an automatically passed in reference to the class itself, passing in name and house. differentiating a student object first. Therein lies the potential chicken and the egg problem. And if unfamiliar, that's an expression meaning, well, did the world have chickens first that laid eggs? Or was there an egg that then yielded the chickens? But how did the egg get there? It's this sort of weird circular problem. And that's what we're facing here. It would be weird if you had to create a student object in order to call get, in order to get another student object? Like, that sounds messy. a student object first, just like the hat. In its final form, we use the hat class to just say hat, capital H, dot sort. We didn't need to create a hat first. We just used the class itself. So what am I going to do here now? Let me go down to main. And instead of saying get student, notice what I can now do. Student dot get. And everything else can stay the same. All I've done now is I've migrated all of my logic from get student, which tells me what's going on. I don't need a separate function written by me. called get student in the file itself, the get functionality is built into The code now is together. So let me go down to my terminal window and run Python of student.py, enter. Let's type in Harry. Let's type in Gryffindor. And we're back to where we began. But, but, but everything related to students now is in this here class. The only other thing in the file is main and this conditional that we always use to avoid accidentally executing main when we're making a module or a package or the like. So again, a solution to a problem, not a big one in the case this. And notice Technically, line 2 is mentioning-- student, which does not exist until line six, go ahead and clear my terminal and run python of student pi. Gryffindor. And indeed, Harry's from Gryffindor. The reason, Michael, it does not matter in this case is because we're not actually calling main until the very end. And just as in the past, that means that Python has a chance to read everything, top to bottom, left to right, so everything exists. I would say generally classes are defined at the top of the file. However, it would be even maybe cleaner to move the class's definition to its own file and then import it. So essentially to make reusable code by putting it into your own module or package that we thought we'd do is focus really on some final core features that you see, not just in Python, but other languages as well. And perhaps one of the most compelling features of object-oriented programming that we haven't yet used explicitly, though it turns out we've seen implicitly over the past weeks, is this notion of inheritance. It turns out, via object-oriented programming, there's actually an opportunity to design your classes in a hierarchical fashion, whereby you can have one class mean by this here? Well, let me propose that we implement over in VS Code here a brand new file called wizard.py. Let me go ahead and run code of wizard.py. And then let's start as before defining a class called student. And let's go ahead and first define the underscore, underscore, init method, which of course is minimally going to take an argument traditionally called self. And in this case, let's also have it take as before a name and a house. implementing the notion of a professor in the wizarding world as well. So for this class, let's call it professor. And a professor, let's say, is also going to have its own initialization method. So underscore, underscore init. It's going to take self, as always, as the first argument. A professor also has a name, so we'll pass that in second too. And even though some professors are heads of houses, let's assume that a professor is really identified by their name and their subject area, the class that they teach. there's probably a better way so that we can write the code once and perhaps reuse it in some way. And here too, object-oriented programming offers a solution. It turns out that object-oriented programming in Python also supports inheritance, whereby you can define multiple classes that somehow relate to one another. They don't need to exist sort of in parallel in this way. There could actually be some hierarchy between them. So for instance, in the wizarding world, we could argue that both a student Professor, why don't I do the same? Let's get rid of the error checking. Let's get rid of self.name equals name, because again, I'm doing that already up there. for wizard as well. But at the moment, even though they're all in the same file, I haven't told Python that a student is a wizard and a professor is a wizard. So I really need to link these two together. And the way you can prescribe inheritance, whereby one class should inherit from another, or conversely, one class should descend from another, we can do this. I can say class student, but before the colon, I can go in and say in parentheses, is still allowing me to do all of the name assignment and the error checking up in the wizard class instead, I think we're OK now by just calling super.init for both student and professor alike. Now, admittedly, this syntax is definitely out there. The fact that we're calling super in parentheses and dots and underscore, underscore on the left and the right of init here, but it's just a combination of these two ideas. Super, open parenthesis, closed parenthesis, is a way of programmatically accessing a current class's parent class assignment of a wizard's name, whether that wizard is a student or a professor. And it's even doing some error checking to make sure the name was actually passed in. Meanwhile, student is inheriting all of that functionality and using it by calling the superclass's own init method. But it's additionally taking the house that's presumably passed into the student constructor function and assigning it to its own instance variable, self.house. And similarly, professor are restoring in self.subject, the subject that was passed lowercase and uppercase on the right, respectively. Professor quote unquote Severus, and how about-- against the dark. be his subject. And meanwhile, if we want to. more generically just a wizard. moment is not. neither student nor professor teaching classes actively, we could that, we could do wizard equals wizard in capital W on the right-hand side of the equal sign, because it's the name of the class, and someone like Albus, passing in only Albus's name, not a house, not a subject, because in this case, he's known only as a wizard. Meanwhile, with each of these calls, this line of code here will ensure that the init method for the wizard class is called. This line of code here will ensure that the init method of the student class,
02:27:41 --> 02:27:43
Speaker 3:
as well but
02:27:43 --> 02:44:30
Speaker 1:
wizard, let's say a really good question. If you were to have a super super class, so your hierarchy taller than the two levels of hierarchy that we currently have? Absolutely. But what's nice about inheritance, as the name implies, is just as you might have inherited certain traits as a human from your grandfather and grandmother or your great grandfather or great grandmother, some of those properties can actually trickle down to you, so to speak, in the context of code as well. So when you descend from another class, that is when you subclass a super class or a super super class, you actually do inherit all of the functionality, not just from one level above you, but from two or three. So you can indeed access some of that functionality as well. And you can even override it if you want some of these classes to behave a little bit differently than others. Other questions on inheritance? So it's kind of similar to the last one, but can you have like two parents common functionality up above. So it turns out that when you use the try and the accept keyword in Python, generally speaking, we've tried to catch very specific exceptions, like value error. But technically, you could capture the parent or even the grandparent exception for a given exception, especially if you're not necessarily sure which one is going to get raised. Or better yet, there could be many exceptions that get raised, but you want to handle them all the same. And you don't want to necessarily enumerate them in parentheses separated by commas. object-oriented programming that we'd like to share with you today, and that it will perhaps be quite the eye-opener as what you can really do now that you have classes at your disposal. And this, too, surprise, has been a feature you and I have been taking for granted for weeks now. This has just worked, but it's been implemented in a way that you can now leverage yourself. It turns out that Python and some other languages, too, support this notion of operator overloading, whereby you can take very common symbols, and self.sickles equals sickles and self.sickles equals Well, Knut's equals Knut's. I could add some error checking, especially if you don't pass in a number. I could turn these into properties to do even more validation. But let's keep it simple and, as always, focus only on the new ideas. So I'm just going to trust that these values were passed in. And I'm going to immediately assign them to these instance variables. What now do I want to do? Well, let's come up with a way of printing out what is in someone's vault, ultimately. But first, let's do this. Let's create a vault for the potters by creating, via assignment, a new vault. Harry's 100, 50, 25. And now let me go ahead and print Weasley like this. And let's go ahead and clear my terminal window, run python of vault.py. This time that stir method will be invoked twice, once for each of those vault objects. And we'll see indeed that the first one for Harry's got 100, 50, and 25, respectively, versus Ron's 25, 50, and 100, respectively. But now let's do something interesting. Suppose that you wanted to combine the contents of two vaults, be it Harry's of Harry and Ron's galleons. Let's next do sickles equals Potter dot sickles plus Weasley dot sickles. And then lastly, let's do knuts equals Potter dot knuts plus Weasley dot knuts. I've got three variables. What can I now do with these values? Well, let's create a third, a new vault. Total will be the name of this variable equals a new vault, capital V notice. And now let's pass in those three new variables, galleons, sickles, and knuts. 50 and 100 combined through addition now is 125, 100, 125. So pretty straightforward using techniques from weeks ago where we're just declaring a few new variables and doing some addition. But wouldn't it be cool if I could do something like this? if I could just somehow not manually create my own vault and do all of this annoying math up here, what if I could just do Potter plus Weasley and get rid of all of this logic here? Wouldn't it be nice if I overload the operator, we know as plus, just like str does, just like list does, to allow me to add two volts together on the left and the right? Well, it turns out in Python and through operator overloading, there is a way to do just this. If you consult the documentation, there's this and so many Let me do the same for sickles self dot sickles plus other dot sickles. And let me lastly do that for knuts. So self dot knuts plus other dot knuts. But at the end of the day, I'm going to need to return a brand new bigger vault that contains all of those contents together. And if we ultimately want to assign that bigger vault to a variable like total here on the left, we'd better indeed return a value from this add method. So I'm going to go ahead and give myself a brand new vault as This many galleons, this many sickles, and this many So ultimately, doing in this implementation of add is adding together those galleons, sickles, and canuts, passing them to the vault function so that we get a brand new bigger vault and return that all together. Now I've defined this new special method called add that should now just make plus work. vaults. All right, let's see. Let me run down to my terminal window, Python of vault.py, and hit Enter. And voila. And now we've implemented an overloaded operator plus to do what you and I, as humans, would hope would be the case when you add two vaults together. But I've now written the code more specifically to teach Python what it means concretely to add two vaults together. And it's with very similar code, in effect, underneath the hood, into a new list with lists and so many other things. classes as well any questions now on operator overloading or this example here how would you go about creating a function for adding a student and a vault for two
02:44:30 --> 02:44:31
Speaker 4:
classes, how all...
02:44:32 --> 02:44:33
Speaker 5:
be possible?
02:44:33 --> 02:46:33
Speaker 1:
Let me see what happens here. Let's do this. What happens if I add Potter plus a stir object? Yeah. OK, so it would work. I'm just figuring this out as I go here, Eric. So just to be clear, what I did was-- I just changed Weasley to stir just to see what would happen when I add a vault plus a stir. And it will work theoretically. Why? Because so long as the type of value on the left has an add method implemented. Other can be any you want you just have to decide and of what it's going to mean conceptually to add a vault plus a string, which in this case probably doesn't make any sense at all. But it's possible. It's going to be the operand on the left. And I'm inferring that. I did not know the answer a moment ago. I'm inferring that because what I got was an attribute error here on line 11 because Python did not like this. Other.galleons didn't work. But I could make it work by figuring something out. Really good question. Questions on operator overloading. Can you define new operators in python? I don't think so. There is a very long but precise list of operators that you can overload. I do not believe you can assign arbitrary characters to be operators in python. Uh, let me defer to carter in the chat to revoke. Okay. I'm seeing two of my colleagues are saying no, not possible. So I'm gonna go with my first instinct. No. Otherwise, that'd be kind of cool. You could make emoji do whatever you want to. can be overloaded in the context of-- So, if you're looking at the same thing,